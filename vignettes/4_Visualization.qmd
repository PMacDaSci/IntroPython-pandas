---
title: "Visualizing Data"
---

## Overview

In this section, you'll learn how to use `plotnine` in Python to create data visualizations using the grammar of graphics. The grammar of graphics is a high-level framework that simplifies the process of creating plots, allowing you to focus on meaningful and aesthetically pleasing visualizations rather than low-level details.

Several Python packages implement a grammar of graphics, but this tutorial focuses on `plotnine` due to its maturity and ease of use. `plotnine` is inspired by `ggplot2` from the R programming language, making it a familiar tool for those with an R background. Essentially, `plotnine` serves as the Python equivalent of `ggplot2`.

The `plotnine` package streamlines plot creation using data frames by providing an intuitive interface to define variables, customize displays, and modify visual attributes. This approach allows you to adapt to changes in the data or switch between plot types with minimal code modifications, resulting in high-quality, publication-ready plots with little manual adjustment.

Like `ggplot2`, `plotnine` prefers data in the "long" format, where each variable occupies a column, and each observation corresponds to a row. Organizing data this way enhances efficiency when generating complex and varied visualizations, making the plotting process more consistent and flexible.

We will be using an extended version of the Metabric dataset in which columns have been added for the mRNA expression values for selected genes, including estrogen receptor alpha (ESR1), progesterone receptor (PGR), GATA3 and FOXA1.

```{python}
#| warning: false
from plotnine import ggplot, aes, geom_line
import pandas as pd
import numpy as np

# Load the Metabric dataset from the URL into a DataFrame
metabric = pd.read_csv("https://zenodo.org/record/6450144/files/metabric_clinical_and_expression_data.csv")
```

## Building a Basic Plot

The construction of ggplot graphics is incremental, allowing for the addition of new elements in layers. This approach grants users extensive flexibility and customization options, enabling the creation of tailored plots to suit specific needs.

![](http://ohi-science.org/data-science-training/img/rstudio-cheatsheet-ggplot.png){fig-align="center" width="500"}

To build a ggplot using `plotnine`, the following templates can be used for different types of plots. This will be consistently used in subsequent examples.

![](images/ggplot-template.png){fig-align="center" width="500"}

Three things are required for a ggplot:

### 1. The data

We first specify the data frame that contains the relevant data to create a plot. Here we are sending the metabric dataset to the `ggplot()` function.

```{python}
#| warning: false
import plotnine
plotnine.options.figure_size = (6, 4)
plotnine.options.dpi = 50
```

```{python}
#| warning: false
#| message: false
#| error: false
#| fig-align: center
# render plot background
ggplot(data = metabric).draw()
```

This command results in an empty gray panel. We must specify how various columns of the data frame should be depicted in the plot.

### 2. Aesthetics `aes()`

Next, we specify the columns in the data we want to map to visual properties (called aesthetics or `aes` function). e.g. the columns for x values, y values and colours.

Since we are interested in generating a scatter plot, each point will have an x and a y coordinate. Therefore, we need to specify the x-axis to represent the year and y-axis to represent the count.

```{python}
#| message: false
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")).draw()
```

This results in a plot which includes the grid lines, the variables and the scales for x and y axes. However, the plot is empty or lacks data points.

### 3. Geometric Representation `geom_()`

Finally, we specify the type of plot (the *geom*). There are different types of geoms:

```{=html}
<table class="unstyledTable">
<tbody>
<tr>
<td>
```
- ![](images/geom_blank.png){height="63"}
```{=html}
</td>
<td>
```
`geom_blank()` draws an **empty plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_segment.png){height="58"}
```{=html}
</td>
<td>
```
`geom_segment()` draws a **straight line**. `geom_vline()` draws a **vertical line** and `geom_hline()` draws a **horizontal line**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_curve.png){height="58"}
```{=html}
</td>
<td>
```
`geom_curve()` draws a **curved line**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_path.png){height="58"}
```{=html}
</td>
<td>
```
`geom_line()/geom_path()` makes a **line plot**. `geom_line()` connects points from left to right and `geom_path()` connects points in the order they appear in the data.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_point.png){height="58"}
```{=html}
</td>
<td>
```
`geom_point()` produces a **scatterplot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_jitter.png){height="58"}
```{=html}
</td>
<td>
```
`geom_jitter()` adds a small amount of **random noise** to the points in a scatter plot.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_dotplot.png){height="58"}
```{=html}
</td>
<td>
```
`geom_dotplot()` produces a **dot plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_smooth.png){height="58"}
```{=html}
</td>
<td>
```
`geom_smooth()` adds a **smooth trend line to a plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_quantile.png){height="58"}
```{=html}
</td>
<td>
```
`geom_quantile()` draws **fitted quantile with lines** (a scatter plot with regressed quantiles).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_density.png){height="58"}
```{=html}
</td>
<td>
```
`geom_density()` creates a **density plot**.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_histogram.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_histogram()` produces a **histogram**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_bar.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_bar()` makes a **bar chart**. Height of the bar is proportional to the number of cases in each group.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_col.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_col()` makes a **bar chart**. Height of the bar is proportional to the values in data.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_boxplot.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_boxplot()` produces a **box plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_violin.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_violin()` creates a **violin plot**.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_ribbon.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_ribbon()` produces a **ribbon** (y interval defined line).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_area.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_area()` draws an **area plot**, which is a line plot filled to the y-axis (filled lines).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_rect.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_rect()`, `geom_tile()` and `geom_raster()` draw **rectangles**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_polygon.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_polygon()` draws **polygons**, which are filled paths.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_text.png){height="58"}
```{=html}
</td>
<td>
```
`geom_text()` adds **text** to a plot.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_label.png){height="58"}
```{=html}
</td>
<td>
```
`geom_text()` adds **label** to a plot.
```{=html}
</td>
</tr>
</tbody>
</table>
```

The range of geoms available in `plotnine` package can be obtained by navigating to the help page of `geoms` package in the `plotnine` package as follows:

::: scrolling
```{python}
import plotnine
help(plotnine.geoms)
```
:::

Since we are interested in creating a scatter plot, the geometric representation of the data will be in point form. Therefore we use the `geom_point()` function.

To plot the expression of estrogen receptor alpha (ESR1) against that of the transcription factor, GATA3:

```{python}
#| warning: false
#| fig-align: center
# first import the relevant geom function 
from plotnine import geom_point
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point() 
  )
plot.draw()
```

Notice that we use the `+` sign to add a *layer* of points to the plot. This concept bears resemblance to Adobe Photoshop, where layers of images can be rearranged and edited independently. In ggplot, each layer is added over the plot in accordance with its position in the code using the `+` sign.

## Customizing Plots

### Adding Colour

The above plot could be made more informative. For instance, the additional information regarding the ER status could be incorporated into the plot. To do this, we can utilize `aes()` and specify which column in the `metabric` data frame should be represented as the color of the points.

```{python}
#| warning: false
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status")) 
  )
plot.draw()  
```

Notice that we specify the `colour = ER_status` argument in the `aes()` mapping inside the `geom_()` function instead of `ggplot()` function. Aesthetic mappings can be set in both `ggplot()` and individual `geom()` layers and we will discuss the difference in the [Section: Adding Layers](4_Visualization.qmd#sec-adding-layers).

To colour points based on a continuous variable, for example: Nottingham prognostic index (NPI):

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "Nottingham_prognostic_index")) 
  )
plot.draw()  
```

Here, a color scale is used for continuous variables, while discrete or categorical values are represented using discrete colors.

Note that some patient samples lack expression values, leading `ggplot` to remove those points with missing values for ESR1 and GATA3.

### Adding Shape

Let's add shape to points.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1", shape = "factor(Survival_status)")) + 
  geom_point()
  )
plot.draw()  
```

Some aesthetics like shape can only be used with categorical variables:

```{python}
#| fig-align: center
#| error: TRUE
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(shape = "Survival_time"))
  )
plot.draw()  
```

The shape argument allows you to customize the appearance of all data points by assigning the symbol/letter associated with predefined shapes given [here](https://matplotlib.org/stable/api/markers_api.html#module-matplotlib.markers).

To use asterix instead of points in the plot:

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(shape = "*")
  )
plot.draw()  
```

It would be useful to be able to change the shape of all the points. We can do so by setting the size to a single value rather than mapping it to one of the variables in the data set - this has to be done outside the aesthetic mappings (i.e. outside the `aes()` bit) as above.

::: callout-tip
#### Aesthetic Setting vs. Mapping

Instead of mapping an aesthetic property to a variable, you can set it to a single value by specifying it in the layer parameters (outside `aes()`). We map an aesthetic to a variable (e.g., `aes(shape = "Survival_status")`) or set it to a constant (e.g., `shape = "*"`). If you want appearance to be governed by a variable in your data frame, put the specification inside `aes()`; if you want to override the default size or colour, put the value outside of `aes()`.

```{python}
#| fig-align: center
#| layout-ncol: 2
#| eval: false
# size outside aes()
plot1 = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(shape = "*")  
  )
plot1.draw()  

# size inside aes()
plot2 = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(shape = "Survival_status"))
  )
plot2.draw()  
```

The above plots are created with similar code, but have rather different outputs. The first plot **sets** the size to a value and the second plot **maps** (not sets) the size to the three-gene classifier variable.

::: {layout-ncol="2"}
![](images/plot-shape-1.png)

![](images/plot-shape-2.png)
:::
:::

It is usually preferable to use colours to distinguish between different categories but sometimes colour and shape are used together when we want to show which group a data point belongs to in two different categorical variables.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(colour = "factor(PAM50)", shape = "Survival_status"))
  )
plot.draw()  
```

### Adding Size and Transparency

We can adjust the size and/or transparency of the points.

Let's first increase the size of points.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(colour = "PAM50"), size = 2)
  )
plot.draw()  
```

Note that here we add the size argument outside of the the aesthetic mapping.

Size is not usually a good aesthetic to map to a variable and hence is not advised.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(colour = "PAM50", size = "ER_status"))
  )
plot.draw()  
```

Because this value is discrete, the default size scale uses evenly spaced sizes for points categorized on ER status.

Transparency can be useful when we have a large number of points as we can more easily tell when points are overlaid, but like size, it is not usually mapped to a variable and sits outside the `aes()`.

Let's change the transparency of points.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(colour = "3-gene_classifier"), alpha = 0.5)
  )
plot.draw()  
```

### Adding Layers {#sec-adding-layers}

We can add another *layer* to this plot using a different geometric representation (or `geom_` function) we discussed previously.

Let's add trend lines to this plot using the `geom_smooth()` function which provide a summary of the data.

```{python}
#| fig-align: center
from plotnine import geom_smooth
plot = (
  ggplot(data = metabric) + geom_point(mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_smooth(mapping = aes(x = "GATA3", y = "ESR1"), method="lm")
  )
plot.draw()  
# Method can be one of ['lm', 'ols', 'wls', 'rlm', 'glm', 'gls', 'lowess', 'loess', 'mavg', 'gpr'] by default method is set to lm (linear model)
```

Note that the shaded area surrounding the black line represents the standard error bounds on the fitted model.

There is some annoying duplication of code used to create this plot. We've repeated the exact same aesthetic mapping for both geoms. We can avoid this by putting the mappings in the `ggplot()` function instead.

```{python}
#| fig-align: center
#| warning: false
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point() + 
  geom_smooth()
  )
plot.draw()  
```

Geom layers specified earlier in the command are drawn first, preceding subsequent geom layers. The sequence of geom layers specified in the command determines their order of appearance in the plot.

If you switch the order of the `geom_point()` and `geom_smooth()` functions above, you'll notice a change in the regression line. Specifically, the regression line will now be plotted underneath the points.

Let's make the plot look a bit prettier by reducing the size of the points and making them transparent. We're not mapping size or alpha to any variables, just setting them to constant values, and we only want these settings to apply to the points, so we set them inside `geom_point()`.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(size = 1, alpha = 0.5) + 
  geom_smooth() 
  )
plot.draw()  
```

::: callout-tip
##### Aesthetic Specifications in Plot vs. Layers

Aesthetic mappings can be provided either in the initial `ggplot()` call, in individual layers, or through a combination of both approaches. When there's only one layer in the plot, the method used to specify aesthetics doesn't impact the result.

```{python}
#| fig-align: center
#| layout-ncol: 2
#| eval: false

# colour argument inside ggplot()
plot1 = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  geom_smooth() 
  )
plot1.draw()  

# colour argument inside geom_point()
plot2 = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(mapping = aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() 
  )
plot2.draw()  
```

::: {layout-ncol="2"}
![](images/plot-aes-1.png)

![](images/plot-aes-2.png)
:::

In the left plot, since we specified the colour (i.e., `colour = "ER_status"`) inside the `ggplot()` function, the `geom_smooth()` function will fit regression lines for each type of ER status and will have coloured regression lines as shown above. This is because, when aesthetic mappings are defined in `ggplot()`, at the global level, they're passed down to each of the subsequent geom layers of the plot.

If we want to add colour only to the points and fit a regression line across all points, we could specify the colour inside `geom_point()` function (i.e., right plot).
:::

Suppose you've spent a bit of time getting your scatter plot just right and decide to add another layer but you're a bit worried about interfering with the code you so lovingly crafted, you can set the `inherit.aes` option to `False` and set the aesthetic mappings explicitly for your new layer.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  geom_smooth(aes(x = "GATA3", y = "ESR1"), inherit_aes=False)
  )
plot.draw()  
```

### Coordinate Space

`ggplot` automatically selects the scale and type of coordinate space for each axis. The majority of plots utilize Cartesian coordinate space, characterized by linear x and y scales.

```{python}
#| fig-align: center
#| warning: false
from plotnine import lims, xlim,ylim, coord_cartesian
# assign a variable to the plot
gata_esrp = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth()
  )
gata_esrp.draw()  
```

We can change the axes limits as follows:

```{python}
#| eval: false
# change both x and y axes
t1 = gata_esrp + lims(x = (0, 13), y = (0, 14))
t1.draw()

# change x axis
t2 = gata_esrp + xlim(5, 9)  
t2.draw()

# change x axis
t3 = gata_esrp + ylim(0, 13)
t3.draw()
```

::: {layout-ncol="3"}
![](images/plot-limits-1.png) 

![](images/plot-limits-2.png) 

![](images/plot-limits-3.png)
:::

Notice that we assigned a variable named `gata_esrp` to our plot and modify it by adding labels. In `ggplot`, you have the flexibility to assign a variable to plot and then modify it by adding layers to the plot. This approach allows you to progressively build up your visualization, incorporating various elements to convey the desired information effectively.

::: callout-tip
##### `lims()/xlim()/ylim()` vs. `coord_cartesian()`

When you set the limits using any of the `lims()/xlim()/ylim()` functions, it discards all data points outside the specified range. Consequently, the regression line is computed across the remaining data points. In contrast, `coord_cartesian()` adjust limits **without** discarding the data, thus offering a visual zoom effect.

```{python}
#| fig-align: center
#| eval: false
#| layout-ncol: 2
p1 = (gata_esrp + ylim(7, 10))
p1.draw()

p2 = (gata_esrp + coord_cartesian(ylim = (7, 10)))
p2.draw()
```

::: {layout-ncol="2"}
![](images/plot-coord-1.png) 

![](images/plot-coord-2.png) 
:::

:::

### Axis Labels

By default, `ggplot` use the column names specified inside the `aes()` as the axis labels. We can change this using the `xlab()` and `ylab()` functions.

```{python}
#| fig-align: center
#| warning: false
from plotnine import xlab, ylab
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  xlab("GATA3 Expression") + 
  ylab("ESR1 Expression")
  )
plot.draw()  
```

### Customizing Plots

You can customize plots to include a title, a subtitle, a caption or a tag.

To add a title:

```{python}
#| fig-align: center
#| warning: false
from plotnine import ggtitle
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  ggtitle("Expression of estrogen receptor alpha against the transcription factor")
  )
plot.draw()  
```

We can use the `labs()` function to add a title and additional information.

```{python}
#| fig-align: center
#| warning: false
from plotnine import labs
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  labs(
    title = "Expression of estrogen receptor alpha against the transcription factor", 
    subtitle = "ESR1 vs GATA3", 
    caption = "This is a caption", 
    y = "ESR1 Expression")
  )
plot.draw()  
```

### Themes

Themes control the overall appearance of the plot, including background color, grid lines, axis labels, and text styles. ggplot offers several built-in themes, and you can also create custom themes to match your preferences or the requirements of your publication. The default theme has a grey background.

```{python}
#| fig-align: center
from plotnine import theme_bw
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "ER_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  theme_bw()
  )
plot.draw()  
```

Try these themes yourselves: `theme_classic()`, `theme_dark()`, `theme_grey()` (default), `theme_light()`, `theme_linedraw()`, `theme_minimal()`, `theme_void()` and `theme_test()`.


### Facets

To enhance readability and clarity, we can break the above plot into sub-plots, called *faceting*. *Facets* are commonly used to split a plot into multiple panels based on the values of one or more variables. This can be useful for exploring relationships in the data across different subsets or categories.

To do this, we specify the column name that will form each facet.

```{python}
#| fig-align: center
from plotnine import facet_wrap, facet_grid
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "PR_status"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  facet_wrap("PR_status")
  )
plot.draw()  
```

Note that the aesthetics and geoms including the regression line that were specified for the original plot, are applied to each of the facets.

Faceting is usually better than displaying groups using different colours when there are more than two or three groups when it can be difficult to really tell which points belong to each group. A case in point is for the three-gene classification in the GATA3 vs ESR1 scatter plot we created above. Let's create a faceted version of that plot.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "3-gene_classifier"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  facet_wrap("3-gene_classifier")
  )
plot.draw()  
```

This helps explain why the function is called `facet_wrap()`. When it has too many subplots to fit across the page, it wraps around to another row. We can control how many rows or columns to use with the `nrow` and `ncol` arguments.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "3-gene_classifier"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  facet_wrap("3-gene_classifier", nrow = 1)
  )
plot.draw()  
```

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(aes(colour = "3-gene_classifier"), size = 0.5, alpha = 0.5) + 
  geom_smooth() + 
  facet_wrap("3-gene_classifier", ncol = 2)
  )
plot.draw()  
```

We can combine faceting on one variable with a colour aesthetic for another variable. For example, let's show the tumour stage status (Neoplasm histologic grade) using faceting and the HER2 status using colours.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1", colour = "HER2_status")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  facet_wrap("Neoplasm_histologic_grade")
  )
plot.draw()  
```

Instead of this we could facet on more than variable.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  facet_wrap(["Neoplasm_histologic_grade", "HER2_status"])
  )
plot.draw()  
```

Faceting on two variables is usually better done using the other faceting function, \*\*`facet_grid()`<b>. Note that the variable expressions along the rows and the columns of the facet grid is set using `rows=` and `cols=` variables as follows:

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  facet_grid(["Neoplasm_histologic_grade", "HER2_status"])
  )
plot.draw()  
```

Again we can use colour aesthetics alongside faceting to add further information to our visualization.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric, mapping = aes(x = "GATA3", y = "ESR1", colour = "PAM50")) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  facet_grid(["Neoplasm_histologic_grade", "HER2_status"])
  )
plot.draw()  
```

## Bar chart

The metabric study redefined how we think about breast cancer by identifying and characterizing several new subtypes, referred to as *integrative clusters*. Let's create a bar chart of the number of patients whose cancers fall within each subtype in the metabric cohort.

The `geom_bar` is the geom used to plot bar charts. It requires a single aesthetic mapping of the categorical variable of interest to `x`.

```{python}
#| fig-align: center
from plotnine import geom_bar
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster"))
  )
plot.draw()  
```

The dark grey bars are a big ugly - what if we want each bar to be a different colour?

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster", colour = "Integrative_cluster"))
  )
plot.draw()  
```

Colouring the edges wasn't quite what we had in mind. Look at the help for `geom_bar` to see what other aesthetic we should have used.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster", fill = "Integrative_cluster"))
  )
plot.draw()  
```

What happens if we colour (fill) with something other than the integrative cluster?

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster", fill = "ER_status"))
  )
plot.draw()  
```

We get a stacked bar plot.

Note the similarity in what we did here to what we did with the scatter plot - there is a common grammar.

Let's try another stacked bar plot, this time with a categorical variable with more than two categories.

```{python}
#| fig-align: center
#| fig-height: 4
# define 3-gene_classifier column as a categorical column
metabric["3-gene_classifier"] = pd.Categorical(metabric["3-gene_classifier"], 
  categories = ['ER+/HER2- High Prolif', 'ER+/HER2- Low Prolif', 'ER-/HER2-', 'HER2+', 'Undefined'])

# set missing values to the Undefined category defined above  
metabric["3-gene_classifier"] = metabric["3-gene_classifier"].fillna('Undefined')

plot = (
  ggplot(data = metabric) + geom_bar(aes(x = "Integrative_cluster", fill = '3-gene_classifier'))
  )
plot.draw()  
```

We can rearrange the three gene groups into adjacent (dodged) bars by specifying a different position within `geom_bar()`:

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster", fill = "3-gene_classifier"), position = 'dodge')
  )
plot.draw()  
```

What if want all the bars to be the same colour but not dark grey, e.g. blue?

You can set the aesthetics to a fixed value but this needs to be outside the mapping, just like we did before for size and transparency in the scatter plots.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster"), fill = "blue")
  )
plot.draw()  
```

Setting this inside the `aes()` mapping told ggplot2 to map the colour aesthetic to some variable in the data frame, one that doesn't really exist.

::: {.callout-note collapse="true"}
### Expand To Learn About Statistical transformations

You may have noticed that `ggplot` didn't just plot values from our data set but had to do some calculation first for the bar chart, i.e. it had to sum the number of observations in each category.

Each geom has a **statistical transformation**. In the case of the scatter plot, `geom_point` uses the "identity" transformation which means just use the values as they are (i.e. not really a transformation at all). The statistical transformation for `geom_bar` is "count", which means it will count the number of observations for each category in the variable mapped to the x aesthetic.

You can see which statistical transformation is being used by a geom by looking at the `stat` argument in the help page for that geom.

There are some circumstances where you'd want to change the `stat`, for example if we already had count values in our table.

```{python}
#| fig-align: center
#| fig-height: 4
#| layout-ncol: 2
#| eval: false
# the previous plot
plot1 = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster"))
  )
plot1.draw()  

# Count the occurrences of each category in the 'Integrative_cluster' column
counts = metabric["Integrative_cluster"].value_counts()
# Convert the series to a DataFrame with index as a column
counts_df = counts.reset_index()
# same plot after computing counts and using the identity stat
plot2 = (
  ggplot(data = counts_df) + 
  geom_bar(aes(x = "Integrative_cluster", y = "count"), stat = "identity")
  )
plot2.draw()  
```

::: {layout-ncol=2}
![](images/plot-bar-1.png)

![](images/plot-bar-2.png)
:::

:::

## Box plot

Box plots (or *box & whisker plots*) are a particular favourite seen in many seminars and papers. Box plots summarize the distribution of a set of values by displaying the minimum and maximum values, the median (i.e. middle-ranked value), and the range of the middle 50% of values (inter-quartile range). The whisker line extending above and below the IQR box define Q3 + (1.5 x IQR), and Q1 - (1.5 x IQR) respectively.

![](https://miro.medium.com/max/18000/1*2c21SkzJMf3frPXPAR_gZA.png) To create a box plot from Metabric dataset:

```{python}
#| fig-align: center
#| fig-height: 4
from plotnine import geom_boxplot, geom_jitter
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3")) + 
  geom_boxplot()
  )
plot.draw()  
```

See `geom_boxplot` help to explain how the box and whiskers are constructed and how it decides which points are outliers and should be displayed as points.

How about adding another layer to display all the points?

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3")) + 
  geom_boxplot() + 
  geom_point()
  )
plot.draw()  
```

Ideally, we'd like these points to be spread out a bit. The help page of `geom_point` fucntion points to `geom_jitter` as more suitable when one of the variables is categorical.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3")) + 
  geom_boxplot() + 
  geom_jitter()
  )
plot.draw()  
```

Well, that's a bit of a mess. We can bring the `geom_boxplot()` layer forward:

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3")) + 
  geom_jitter() + 
  geom_boxplot(alpha = 0.5) 
  )
plot.draw()  
```

Still not the best plot. We can reduce the spread or jitter and make the points smaller and transparent:

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3")) + 
  geom_boxplot() + 
  geom_jitter(width = 0.3, size = 0.5, alpha = 0.25)
  )
plot.draw()  
```

Displaying points in this way makes much more sense when we only have a few observations and where the box plot masks the fact, perhaps giving the false impression that the sample size is larger than it actually is. Here it makes less sense as we have very many observations.

Let's try a colour aesthetic to also look at how estrogen receptor expression differs between HER2 positive and negative tumours.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3", colour = "HER2_status")) + 
  geom_boxplot() 
  )
plot.draw()  
```

## Violin plot

A *violin plot* is used to visualize the distribution of a numeric variable across different categories. It combines aspects of a box plot and a kernel density plot.

The width of the violin at any given point represents the density of data at that point. Wider sections indicate a higher density of data points, while narrower sections indicate lower density. By default, violin plots are symmetric.

```{python}
#| fig-align: center
#| fig-height: 4
from plotnine import geom_violin, position_dodge
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3", colour = "HER2_status")) + 
  geom_violin()
  )
plot.draw()  
```

Inside each violin plot, a box plot is often included, showing additional summary statistics such as the median, quartiles, and potential outliers. This helps provide a quick overview of the central tendency and spread of the data within each category.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3", colour = "HER2_status")) + 
  geom_violin() + 
  geom_boxplot(width = 0.8, alpha = 0.4)
  )
plot.draw()  
```

In the above plot, the violin plots and box plots are misaligned. You can read the cause of this [here](https://stackoverflow.com/questions/73900036/boxplot-and-violin-plot-misaligned-in-ggplot2-for-only-one-level-of-the-x-axis).

To align them, we can use the `position_dodge()` function to manually adjusting the horizontal position as follows.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric, mapping = aes(x = "ER_status", y = "GATA3", colour = "HER2_status")) + 
  geom_violin(position = position_dodge(0.8)) + 
  geom_boxplot(width = 0.8, alpha = 0.4)
  )
plot.draw()  
```

## Histogram

The geom for creating histograms is, rather unsurprisingly, `geom_histogram()`.

```{python}
#| fig-align: center
#| fig-height: 4
from plotnine import geom_histogram
plot = (
  ggplot(data = metabric) + 
  geom_histogram(aes(x = "Age_at_diagnosis"))
  )
plot.draw()  
```

The warning message hints at picking a more optimal number of bins by specifying the `binwidth` argument.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_histogram(aes(x = "Age_at_diagnosis"), binwidth = 5)
  )
plot.draw()  
```

Or we can set the number of bins.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_histogram(aes(x = "Age_at_diagnosis"), bins = 20)
  )
plot.draw()  
```

These histograms are not very pleasing, aesthetically speaking - how about some better aesthetics?

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_histogram(aes(x = "Age_at_diagnosis"), bins = 20, colour = "darkblue", fill = "grey")
  )
plot.draw()  
```

## Density plot

Density plots are used to visualize the distribution of a continuous variable in a dataset. These are essentially smoothed histograms, where the area under the curve for each sub-group will sum to 1. This allows us to compare sub-groups of different size.

```{python}
#| fig-align: center
#| fig-height: 4
from plotnine import geom_density
plot = (
  ggplot(data = metabric) + 
  geom_density(aes(x = "Age_at_diagnosis", colour = "Integrative_cluster"))
  )
plot.draw()  
```

## Categorical variables

Several of the variables in the Metabric data set are categorical. Some of these have been read into Python as character types (e.g. the three gene classifier), other as numerical values (e.g. tumour stage). We also have some binary variables that are essentially categorical variables but with only 2 possible values (e.g. ER status).

In many of the plots given above, `ggplot` has treated character variables as categorical in situations where a categorical variable is expected. For example, when we displayed points on a scatter plot using different colours for each three gene classification, or when we created separate box plots in the same graph for ER positive and negative patients.

But what about when our categorical variable has been read into Python as a continuous variable, e.g. `Tumour_stage`, which is read in as a double type.

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_point(aes(x = "GATA3", y = "ESR1", colour = "Tumour_stage"))
  )
plot.draw()  
```

```{python}
metabric.Tumour_stage.unique()
```

Tumour stage has only 5 discrete states but `ggplot` doesn't know these are supposed to be a restricted set of values and has used a colour scale to show them as if they were continuous. We need to tell Python that these are categorical (or factors).

Let's convert our tumour stage variable to a factor using the `Categorical()` function.

```{python}
#| classes: scrolling
metabric["Tumour_stage"] = pd.Categorical(metabric["Tumour_stage"])
# or directly convert the type to category
# metabric["Tumour_stage"] = metabric["Tumour_stage"].astype("category")
metabric[["Tumour_stage", "Patient_ID"]].head()
```

Python actually stores categorical variables as integers but with some additional metadata about which of the integer values, or 'categories', corresponds to each category.

```{python}
type(metabric["Tumour_stage"])
metabric["Tumour_stage"].cat.categories
```

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_point(aes(x = "GATA3", y = "ESR1", colour = "Tumour_stage"))
  )
plot.draw()  
```

In this case the order of the categories makes sense but for other variables you may wish for more control over the ordering. Take the integrative cluster variable for example. We created a bar plot of the numbers of patients in the Metabric cohort within each integrative cluster. Did you notice the ordering of the clusters? 10 came just after 1 and before 2. That looked a bit odd as we'd have naturally expected it to come last of all. Python, on the other hand, is treating this vector as a character vector (mainly because of the 'ER-' and 'ER+' subtypes of cluster 4, and sorts the values into alphanumerical order.

```{python}
metabric["Integrative_cluster"] = pd.Categorical(metabric["Integrative_cluster"])
metabric["Integrative_cluster"].cat.categories
```

We can create a factor using the `Categorical()` function and specify the categories using the `categories` argument.

```{python}
metabric["Integrative_cluster"] = pd.Categorical(metabric["Integrative_cluster"], 
  categories = ["1", "2", "3", "4ER-", "4ER+", "5", "6", "7", "8", "9", "10"])
metabric["Integrative_cluster"].cat.categories
```

```{python}
#| fig-align: center
#| fig-height: 4
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "Integrative_cluster", fill = "Integrative_cluster"))
  )
plot.draw()  
```

### Line plot

A *line plot* is used to display the trend or pattern in data over a continuous range of values, typically along the x-axis (horizontal axis).

Before we create a line plot, let's start by reading a subset of cancer_mort dataset using the `read_csv()` function:

```{python}
#| message: false
# first read the dataset
cancer_mort_full = pd.read_csv("data/Australian_Cancer_Incidence_and_Mortality.csv")  
# lets consider the rows with cancer types that starts with B letters only. 
# this is done for illustartion purposes. 
cancer_mort = cancer_mort_full[cancer_mort_full.Cancer_Type.str.contains('^B[a-z]+')]
```

Next, we filter the cancer_mort data frame to plot only the counts for the female patients in the age group 55-59 and are categorized as moratality cases.

```{python}
# define a new subset from cancer_mort dataset
cancer_mort_55 = cancer_mort.query("Age == '55-59' and Type == 'Mortality' and Sex == 'Female'")
```

```{python}
#| fig-align: center
#| fig-height: 4
from plotnine import geom_line
plot = (
  ggplot(data = cancer_mort_55, mapping = aes(x = "Year", y = "Count")) + 
  geom_line(aes(colour = "Cancer_Type"))
  )
plot.draw()  
```

Another aesthetic available for `geom_line` is linetype.

```{python}
#| fig-align: center
#| fig-height: 4
cancer_count = (
  ggplot(data = cancer_mort_55, mapping = aes(x = "Year", y = "Count")) + 
  geom_line(aes(linetype = "Cancer_Type")) 
  )
cancer_count.draw()  
```

## Saving plot images

Use `ggsave()` to save a plot.

```{python}
#| eval: false
cancer_count.save("Cancer_type_vs_count.png")
```

You can alter the width and height of the plot and can change the image file type.

```{python}
#| eval: false
cancer_count.save("Cancer_type_vs_count.pdf", width = 20, height = 12, units = "cm")
```

## Customizing Plots - continued

### Scales

One of the components of the plot is called `scales`. `ggplot` automatically adds default scales behind the scene equivalent to the following:

```{python}
#| fig-align: center
from plotnine import geom_smooth, scale_x_continuous, scale_y_continuous, scale_colour_discrete
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "Nottingham_prognostic_index", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.6, alpha = 0.5) + 
  geom_smooth(method = "lm") + 
  scale_x_continuous() + 
  scale_y_continuous() + 
  scale_colour_discrete()
  )
plot.draw()  
```

Note that we have three aesthetics and ggplot adds a scale for each.

```{python}
plot.mapping
```

The x and y variables (`Nottingham_prognostic_index` and `ESR1`) are continuous so `ggplot` adds a continuous scale for each. `ER_status` is a discrete variable in this case so `ggplot` adds a discrete scale for colour.

Generalizing, the scales that are required follow the naming scheme:

```{python}
#| eval: false
scale_<NAME_OF_AESTHETIC>_<NAME_OF_SCALE>
```

Look at the help page for `scale_y_continuous` to see what we can change about the y-axis scale (To view the help page run the command: `help(plotnine.scale_y_continuous)`).

First we'll change the breaks, i.e. where `ggplot` puts ticks and numeric labels, on the y axis.

```{python}
#| fig-align: center
scat_plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "Nottingham_prognostic_index", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.6, alpha = 0.5) + 
  geom_smooth(method = "lm")
  )

plot = (
  scat_plot + scale_y_continuous(breaks = np.arange(5, 15, 2.5).tolist())
  )
plot.draw()  
```

`arange()` is a useful function for generating regular sequences of numbers. In this case we wanted numbers from 5 to 15 going up in steps of 2.5.

```{python}
np.arange(5, 15, 2.5)
```

We could do the same thing for the x axis using `scale_x_continuous()`.

We can also adjust the extents of the x or y axis.

```{python}
#| fig-align: center
plot = (
  scat_plot + 
  scale_y_continuous(breaks = np.arange(5, 15, 2.5).tolist(), limits = (4, 12))
  )
plot.draw()  
```

Here, just for demonstration purposes, we set the upper limit to be less than the largest values of ESR1 expression and `ggplot` warned us that some rows have been removed from the plot.

We can change the minor breaks, e.g. to add more lines that act as guides. These are shown as thin white lines when using the default theme.

```{python}
#| fig-align: center
plot = (
  scat_plot + 
  scale_y_continuous(
    breaks = np.arange(5, 12.5, 2.5).tolist(), 
    limits = (5, 13.5), 
    minor_breaks = np.arange(5, 13.5, 0.5).tolist())
  )
plot.draw()  
```

Or we can remove the minor breaks entirely.

```{python}
#| fig-align: center
plot = (
  scat_plot + 
  scale_y_continuous(
    breaks = np.arange(6, 14, 2).tolist(), 
    limits = (5, 13.5), 
    minor_breaks = False)
  )
plot.draw()  
```

Similarly we could remove all breaks entirely.

```{python}
#| fig-align: center
plot = (
  scat_plot + scale_y_continuous(breaks = False)
  )
plot.draw()  
```

A more typical scenario would be to keep the breaks, because we want to display the ticks and their lables, but remove the grid lines. Somewhat confusingly the position of grid lines are controlled by a scale but preventing these from being displayed requires changing the theme. The theme controls the way in which non-data components are displayed -- we'll look at how these can be customized later. For now, though, here's an example of turning off the display of all grid lines for major and minor breaks for both axes.

```{python}
#| fig-align: center
from plotnine import theme, element_blank
plot = (
  scat_plot + 
  scale_y_continuous(breaks = np.arange(4, 14, 2), limits = (4, 14)) + 
  theme(panel_grid = element_blank())
  )
plot.draw()  
```

By default, the scales are expanded by 5% of the range on either side. We can add or reduce the space as follows.

```{python}
#| fig-align: center
plot = (
  scat_plot + 
  scale_x_continuous(expand = (0.01, 0)) + 
  scale_y_continuous(expand = (0.25, 0))
  )
plot.draw()  
```

Here `expand =` argument refers to multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:

```         
(mul, add)
(mul_low, add_low, mul_high, add_high)
```

For example, 

  - `(0, 0)` : Do not expand. 
  - `(0, 1)` : Expand lower and upper limits by 1 unit. 
  - `(1, 0)` : Expand lower and upper limits by 100%. 
  - `(0, 0, 0, 0)` : Do not expand, as `(0, 0)`. 
  - `(0, 0, 0, 1)` : Expand upper limit by 1 unit. 
  - `(0, 1, 0.1, 0)` : Expand lower limit by 1 unit and upper limit by 10%. 
  - `(0, 0, 0.1, 2)` : Expand upper limit by 10% plus 2 units.

Here we only added 1% (0.01) of the range of NPI values on either side along the x axis but we added 25% (0.25) of the range of ESR1 expression on either side along the y axis.

### Colours

The colour asthetic is used with a categorical variable, `ER_status`, in the scatter plots we've been customizing. The default colour scale used by `ggplot` for categorical variables is `scale_colour_discrete`. We can manually set the colours we wish to use using `scale_colour_manual` instead.

```{python}
#| fig-align: center
from plotnine import scale_colour_manual  
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "Nottingham_prognostic_index", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.6, alpha = 0.5) + 
  geom_smooth(method = "lm") + scale_colour_manual(values = ["dodgerblue", "firebrick"])
  )
plot.draw()  
```

The following figure displays the names of the colors available to use in the `scale_colour_manual()` function in `plotnine`. These color names can be directly used to customize the appearance of your plots.

```{python}
#| fig-align: center
#| echo: false
import matplotlib
import math

import matplotlib.pyplot as plt

import matplotlib.colors as mcolors
from matplotlib.patches import Rectangle


def plot_colortable(colors, *, ncols=4, sort_colors=True):

    cell_width = 212
    cell_height = 32
    swatch_width = 48
    margin = 12

    # Sort colors by hue, saturation, value and name.
    if sort_colors is True:
        names = sorted(
            colors, key=lambda c: tuple(mcolors.rgb_to_hsv(mcolors.to_rgb(c))))
    else:
        names = list(colors)

    n = len(names)
    nrows = math.ceil(n / ncols)

    width = cell_width * ncols + 2 * margin
    height = cell_height * nrows + 2 * margin
    dpi = 72

    fig, ax = plt.subplots(figsize=(width / dpi, height / dpi), dpi=dpi)
    fig.subplots_adjust(margin/width, margin/height,
                        (width-margin)/width, (height-margin)/height)
    ax.set_xlim(0, cell_width * ncols)
    ax.set_ylim(cell_height * (nrows-0.5), -cell_height/2.)
    ax.yaxis.set_visible(False)
    ax.xaxis.set_visible(False)
    ax.set_axis_off()

    for i, name in enumerate(names):
        row = i % nrows
        col = i // nrows
        y = row * cell_height

        swatch_start_x = cell_width * col
        text_pos_x = cell_width * col + swatch_width + 7

        ax.text(text_pos_x, y, name, fontsize=9,
                horizontalalignment='left',
                verticalalignment='center')

        ax.add_patch(
            Rectangle(xy=(swatch_start_x, y-9), width=swatch_width,
                      height=20, facecolor=colors[name], edgecolor='0.7')
        )

    return fig
  
plot_colortable(mcolors.CSS4_COLORS)
plt.show()
```

To view the list of available color names, you can also refer to the [matplotlib color documentation](https://matplotlib.org/stable/gallery/color/named_colors.html), as plotnine uses matplotlib's color names for setting custom colors in plots.

Setting colours manually is ok when we only have two or three categories but when we have a larger number it would be handy to be able to choose from a selection of carefully-constructed colour palettes. Helpfully, `ggplot` provides access to the [ColorBrewer](http://colorbrewer2.org) palettes through the functions `scale_colour_brewer()` and `scale_fill_brewer()`.

```{python}
#| fig-align: center
from plotnine import scale_colour_brewer
scat_plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "Nottingham_prognostic_index", y = "ESR1", colour = "3-gene_classifier")) + 
  geom_point(size = 0.6, alpha = 0.5, na_rm = True) + 
  geom_smooth(method = "lm") + 
  scale_colour_brewer(type = "qualitative", palette = "Set1")
  )
scat_plot.draw()  
```

Look at the help page for `scale_colour_brewer` to see what other colour palettes are available and visit the [ColorBrewer](http://colorbrewer2.org) website to see what these look like.

Interestingly, you can set other attributes other than just the colours at the same time.

```{python}
#| fig-align: center
# remove legend title for colour now that the labels are self-explanatory
from plotnine import labs
scat_plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "Nottingham_prognostic_index", y = "ESR1", colour = "ER_status")) + 
  geom_point(size = 0.6, alpha = 0.5) + 
  geom_smooth(method = "lm") + 
  scale_colour_manual(values = ["dodgerblue", "firebrick"], labels = ["ER-negative", "ER-positive"]) + 
  labs(colour = '')
  )
scat_plot.draw()  
```

We have applied our own set of mappings from categories in the data to aesthetic values.

For continuous variables we may wish to be able to change the colours used in the colour gradient. To demonstrate this we'll use the Nottingham prognostic index (NPI) values to colour points in the scatter plot of ESR1 vs GATA3 expression on a continuous scale.

```{python}
#| fig-align: center
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "GATA3", y = "ESR1", colour = "Nottingham_prognostic_index")) + 
  geom_point(size = 0.5, na_rm = True)
  )
plot.draw()  
```

Higher NPI scores correspond to worse prognosis and lower chance of 5 year survival. We'll emphasize those points on the scatter plot by adjusting our colour scale.

```{python}
#| fig-align: center
from plotnine import scale_colour_gradient, scale_colour_gradient2
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "GATA3", y = "ESR1", colour = "Nottingham_prognostic_index")) + 
  geom_point(size = 0.75, na_rm = True) + 
  scale_colour_gradient(low = "white", high = "firebrick")
  )
plot.draw()  
```

In some cases it might make sense to specify two colour gradients either side of a mid-point.

```{python}
#| fig-align: center
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "GATA3", y = "ESR1", colour = "Nottingham_prognostic_index")) + 
  geom_point(size = 0.75, na_rm = True) + 
  scale_colour_gradient2(low = "dodgerblue", mid = "#808080", high = "firebrick", midpoint = 4.5)
  )
plot.draw()  
```

As before we can override the default labels and other aspects of the colour scale within the scale function.

```{python}
#| fig-align: center
plot = (
  ggplot(
    data = metabric, 
    mapping = aes(x = "GATA3", y = "ESR1", colour = "Nottingham_prognostic_index")) + 
  geom_point(size = 0.75, na_rm = True) + 
  scale_colour_gradient(
    low = "lightblue", high = "darkblue", name = "NPI Values", 
    breaks = np.arange(2,7), limits = (1.5, 6.5))
  )
plot.draw()  
```

### Themes

Themes can be used to customize non-data components of a plot. Let's create a plot showing the expression of estrogen receptor alpha (ESR1) for each of the Integrative cluster breast cancer subtypes.

```{python}
#| fig-align: center
# plot the ESR1 expression for each integrative cluster
intclust_plot = (
  ggplot(data = metabric) + 
  geom_boxplot(aes(x = "Integrative_cluster", y = "ESR1", fill = "Integrative_cluster")) + 
  labs(x = "Integrative cluster", y = "ESR1 expression")
  )
intclust_plot.draw()  
```

The default theme has the characteristic grey background which isn't particularly suitable for printing on paper. We can change to one of a number of alternative themes available in the ggplot2 package, e.g. the black and white theme.

```{python}
#| fig-align: center
from plotnine import theme_bw
plot = (intclust_plot + theme_bw())
plot.draw()  
```

Each of these themes is really just a collection of attributes relating to how various non-data elements of the plot will be displayed. We can override any of these individual settings using the `theme()` function. A look at the help page (`help(plotnine.theme)`) shows that there are a very large number of settings that you can change. The following example demonstrates a few of these.

```{python}
#| fig-align: center
plot = (
  intclust_plot + 
  theme_bw() + 
  theme(
    panel_grid_major_x = element_blank(), 
    axis_ticks_major_x = element_blank(), 
    legend_position = "none")
  )
plot.draw()  
```

Here's another example that also involves customizing the labels, scales and colours.

```{python}
#| fig-align: center
from plotnine import scale_fill_manual, element_line, element_text
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "3-gene_classifier", fill = "ER_status")) + 
  scale_y_continuous(limits = (0, 700), breaks = np.arange(0, 800, 100), expand = (0,0)) + 
  scale_fill_manual(values = ["firebrick", "dodgerblue"]) + 
  labs(x = '', y = "samples", fill = "ER status") + 
  theme_bw() + 
  theme(
    panel_border = element_blank(), 
    panel_grid = element_blank(), 
    axis_ticks_major_x = element_blank(), 
    axis_text_x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis_line_y = element_line(), 
    axis_ticks_length = 8, 
    legend_position = "bottom")
  )
plot.draw()  
```

### Position adjustments

All geoms in `ggplot` have a position adjustment that can be set using the `position` argument. This has different effects for different types of plot but essentially this resolves how overlapping geoms are displayed.

For example, let's consider the stacked bar plot we created earlier showing the numbers of patients in each of the 3-gene classifications subdivided by ER status. The default position value for `geom_bar()` is "stack" which is why the plot is shown as a stacked bar chart. An alternative way of representing these data would be to show separate bars for each ER status side-by-side by setting `position = "dodge"`.

```{python}
#| fig-align: center
plot = (
  ggplot(data = metabric) + 
  geom_bar(aes(x = "3-gene_classifier", fill = "ER_status"), position = "dodge") + 
  scale_y_continuous(limits = (0, 700), breaks = np.arange(0, 800, 100), expand = (0,0)) + 
  scale_fill_manual(values = ["firebrick", "dodgerblue"]) + 
  labs(x = '', y = "samples", fill = "ER status") + 
  theme_bw() + 
  theme(
    panel_border = element_blank(), 
    panel_grid = element_blank(), 
    axis_ticks_major_x = element_blank(), 
    axis_text_x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis_line_y = element_line(), axis_ticks_length = 8)
  )
plot.draw()  
```

Another position adjustment we've come across is `geom_jitter()`, which is just a convenient shortcut for `geom_point(position = "jitter")`. A variation on this, `position_jitterdodge()`, comes in handy when we are overlaying points on top of a box plot. We show an example of just such a plot in which first use `postion = "jitter"`.

```{python}
#| fig-align: center
from plotnine import scale_color_brewer, theme_minimal
plot = (
  ggplot(data = metabric, mapping = aes(x = "3-gene_classifier", y = "ESR1", colour = "PR_status")) + 
  geom_boxplot() + 
  geom_point(position = "jitter", size = 0.5, alpha = 0.3) + 
  labs(x = "3-gene classification", y = "ESR1 expression", colour = "PR status") + 
  scale_color_brewer(type = "qualitative", palette = "Set1") + 
  theme_minimal() + 
  theme(
    panel_grid_major_x = element_blank(), 
    axis_text_x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis_ticks_major_x = element_blank())
  )
plot.draw()  
```

The PR-negative and PR-positive points have distinct colours but are overlapping in a way that is aesthetically displeasing. What we want is for the points to have both jitter and to be dodged in the same way as the boxes. With `position_jitterdodge()` we get a better looking plot.

```{python}
#| fig-align: center
from plotnine import position_jitterdodge
plot = (
  ggplot(data = metabric, mapping = aes(x = "3-gene_classifier", y = "ESR1", colour = "PR_status")) + 
  geom_boxplot() + 
  geom_point(position = position_jitterdodge(), size = 0.5, alpha = 0.3) + 
  labs(x = "3-gene classification", y = "ESR1 expression", colour = "PR status") + 
  scale_color_brewer(type = "qualitative", palette = "Set1") + 
  theme_minimal() + 
  theme(
    panel_grid_major_x = element_blank(), 
    axis_text_x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis_ticks_major_x = element_blank())
  )
plot.draw()  
```

This concludes the visualization section and the Introduction to Python materials. By now, you should be able to pre-process data, analyze it to uncover insights, and finally create aesthetically pleasing, publication-worthy plots. These skills will equip you with a solid foundation in data manipulation and visualization, enabling you to communicate your findings effectively through both analysis and visual storytelling.

------------------------------------------------------------------------

